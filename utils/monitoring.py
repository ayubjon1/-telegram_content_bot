# utils/monitoring.py - –ù–û–í–´–ô –§–ê–ô–õ
import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from collections import deque, defaultdict
import psutil

logger = logging.getLogger(__name__)


@dataclass
class SystemMetrics:
    """–°–∏—Å—Ç–µ–º–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏"""
    cpu_percent: float
    memory_percent: float
    disk_percent: float
    timestamp: datetime


@dataclass
class Alert:
    """–ê–ª–µ—Ä—Ç —Å–∏—Å—Ç–µ–º—ã"""
    id: str
    level: str  # info, warning, error, critical
    title: str
    message: str
    timestamp: datetime
    resolved: bool = False


class SmartMonitor:
    """–£–º–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""

    def __init__(self, db=None, scheduler=None):
        self.db = db
        self.scheduler = scheduler
        self.running = False

        # –•—Ä–∞–Ω–∏–ª–∏—â–µ –º–µ—Ç—Ä–∏–∫ (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 1000 –∑–∞–ø–∏—Å–µ–π)
        self.system_metrics: deque = deque(maxlen=1000)
        self.active_alerts: Dict[str, Alert] = {}

        # –ü–æ—Ä–æ–≥–æ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
        self.thresholds = {
            'cpu_warning': 70.0,
            'cpu_critical': 85.0,
            'memory_warning': 75.0,
            'memory_critical': 90.0,
            'disk_warning': 80.0,
            'disk_critical': 95.0
        }

        # –°—á–µ—Ç—á–∏–∫–∏ –¥–ª—è –∞–≤—Ç–æ–∏—Å—Ü–µ–ª–µ–Ω–∏—è
        self.healing_actions = defaultdict(int)

        logger.info("üîç –°–∏—Å—Ç–µ–º–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")

    async def start_monitoring(self):
        """–ó–∞–ø—É—Å–∫ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
        if self.running:
            return

        self.running = True

        # –ó–∞–ø—É—Å–∫–∞–µ–º –∑–∞–¥–∞—á–∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
        tasks = [
            asyncio.create_task(self._monitor_system_metrics()),
            asyncio.create_task(self._monitor_services()),
            asyncio.create_task(self._auto_healing_loop())
        ]

        logger.info("üöÄ –°–∏—Å—Ç–µ–º–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∑–∞–ø—É—â–µ–Ω–∞")
        await asyncio.gather(*tasks, return_exceptions=True)

    async def stop_monitoring(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
        self.running = False
        logger.info("‚èπ –°–∏—Å—Ç–µ–º–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞")

    async def _monitor_system_metrics(self):
        """–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤"""
        while self.running:
            try:
                # –°–æ–±–∏—Ä–∞–µ–º –º–µ—Ç—Ä–∏–∫–∏
                cpu_percent = psutil.cpu_percent(interval=1)
                memory = psutil.virtual_memory()
                disk = psutil.disk_usage('/')

                metrics = SystemMetrics(
                    cpu_percent=cpu_percent,
                    memory_percent=memory.percent,
                    disk_percent=disk.percent,
                    timestamp=datetime.now()
                )

                self.system_metrics.append(metrics)

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—Ä–æ–≥–∏
                await self._check_system_thresholds(metrics)

                await asyncio.sleep(30)  # –ö–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥

            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ —Å–±–æ—Ä–∞ –º–µ—Ç—Ä–∏–∫: {e}")
                await asyncio.sleep(60)

    async def _check_system_thresholds(self, metrics: SystemMetrics):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—Ä–æ–≥–æ–≤—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π"""
        alerts = []

        # CPU
        if metrics.cpu_percent > self.thresholds['cpu_critical']:
            alerts.append(('cpu_critical', f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ CPU: {metrics.cpu_percent:.1f}%"))
        elif metrics.cpu_percent > self.thresholds['cpu_warning']:
            alerts.append(('cpu_warning', f"–í—ã—Å–æ–∫–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ CPU: {metrics.cpu_percent:.1f}%"))

        # Memory
        if metrics.memory_percent > self.thresholds['memory_critical']:
            alerts.append(('memory_critical', f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏: {metrics.memory_percent:.1f}%"))
        elif metrics.memory_percent > self.thresholds['memory_warning']:
            alerts.append(('memory_warning', f"–í—ã—Å–æ–∫–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏: {metrics.memory_percent:.1f}%"))

        # Disk
        if metrics.disk_percent > self.thresholds['disk_critical']:
            alerts.append(('disk_critical', f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–æ–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–∏—Å–∫–∞: {metrics.disk_percent:.1f}%"))
        elif metrics.disk_percent > self.thresholds['disk_warning']:
            alerts.append(('disk_warning', f"–í—ã—Å–æ–∫–æ–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–∏—Å–∫–∞: {metrics.disk_percent:.1f}%"))

        # –°–æ–∑–¥–∞–µ–º –∞–ª–µ—Ä—Ç—ã
        for alert_type, message in alerts:
            await self._create_alert(alert_type, message)

    async def _monitor_services(self):
        """–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Å–µ—Ä–≤–∏—Å–æ–≤"""
        while self.running:
            try:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫
                if self.scheduler:
                    if not self.scheduler.running:
                        await self._create_alert(
                            'scheduler_down',
                            "–ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω",
                            level='critical'
                        )
                        # –ê–≤—Ç–æ–∏—Å—Ü–µ–ª–µ–Ω–∏–µ
                        await self._heal_scheduler()

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
                if self.db:
                    try:
                        await self.db.get_setting('health_check')
                    except Exception as e:
                        await self._create_alert(
                            'database_error',
                            f"–û—à–∏–±–∫–∞ –ë–î: {str(e)[:100]}",
                            level='error'
                        )

                await asyncio.sleep(60)  # –ö–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É

            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Å–µ—Ä–≤–∏—Å–æ–≤: {e}")
                await asyncio.sleep(120)

    async def _auto_healing_loop(self):
        """–¶–∏–∫–ª –∞–≤—Ç–æ–∏—Å—Ü–µ–ª–µ–Ω–∏—è"""
        while self.running:
            try:
                # –ê–≤—Ç–æ–∏—Å—Ü–µ–ª–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∞–ª–µ—Ä—Ç–æ–≤
                for alert_id, alert in list(self.active_alerts.items()):
                    if not alert.resolved and alert.level in ['error', 'critical']:
                        await self._attempt_healing(alert)

                await asyncio.sleep(120)  # –ö–∞–∂–¥—ã–µ 2 –º–∏–Ω—É—Ç—ã

            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –∞–≤—Ç–æ–∏—Å—Ü–µ–ª–µ–Ω–∏—è: {e}")
                await asyncio.sleep(300)

    async def _create_alert(self, alert_type: str, message: str, level: str = 'warning'):
        """–°–æ–∑–¥–∞–Ω–∏–µ –∞–ª–µ—Ä—Ç–∞"""
        alert_id = f"{alert_type}_{int(datetime.now().timestamp())}"

        # –ò–∑–±–µ–≥–∞–µ–º –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –∞–ª–µ—Ä—Ç–æ–≤
        existing = [a for a in self.active_alerts.values()
                    if a.title == alert_type and not a.resolved]
        if existing:
            return

        alert = Alert(
            id=alert_id,
            level=level,
            title=alert_type,
            message=message,
            timestamp=datetime.now()
        )

        self.active_alerts[alert_id] = alert

        # –õ–æ–≥–∏—Ä—É–µ–º –∞–ª–µ—Ä—Ç
        log_level = {
            'info': logger.info,
            'warning': logger.warning,
            'error': logger.error,
            'critical': logger.critical
        }.get(level, logger.warning)

        log_level(f"üö® ALERT [{level.upper()}]: {message}")

    async def _attempt_healing(self, alert: Alert):
        """–ü–æ–ø—ã—Ç–∫–∞ –∞–≤—Ç–æ–∏—Å—Ü–µ–ª–µ–Ω–∏—è"""
        healing_method = {
            'cpu_critical': self._heal_cpu_issues,
            'memory_critical': self._heal_memory_issues,
            'scheduler_down': self._heal_scheduler,
            'database_error': self._heal_database
        }.get(alert.title)

        if healing_method:
            try:
                success = await healing_method()
                if success:
                    alert.resolved = True
                    self.healing_actions[alert.title] += 1
                    logger.info(f"‚úÖ –ê–≤—Ç–æ–∏—Å—Ü–µ–ª–µ–Ω–∏–µ: {alert.title} –∏—Å–ø—Ä–∞–≤–ª–µ–Ω")

            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∞–≤—Ç–æ–∏—Å—Ü–µ–ª–µ–Ω–∏—è {alert.title}: {e}")

    async def _heal_cpu_issues(self) -> bool:
        """–ò—Å—Ü–µ–ª–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º —Å CPU"""
        try:
            # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è —Å–±–æ—Ä–∫–∞ –º—É—Å–æ—Ä–∞
            import gc
            collected = gc.collect()
            logger.info(f"üîß CPU –∏—Å—Ü–µ–ª–µ–Ω–∏–µ: —Å–æ–±—Ä–∞–Ω–æ {collected} –æ–±—ä–µ–∫—Ç–æ–≤")

            # –°–Ω–∏–∂–∞–µ–º —á–∞—Å—Ç–æ—Ç—É –ø—Ä–æ–≤–µ—Ä–æ–∫ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞
            if hasattr(self.scheduler, '_scheduler_task'):
                logger.info("üîß –°–Ω–∏–∂–µ–Ω–∞ —á–∞—Å—Ç–æ—Ç–∞ –ø—Ä–æ–≤–µ—Ä–æ–∫ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞")

            return True

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∏—Å—Ü–µ–ª–µ–Ω–∏—è CPU: {e}")
            return False

    async def _heal_memory_issues(self) -> bool:
        """–ò—Å—Ü–µ–ª–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º —Å –ø–∞–º—è—Ç—å—é"""
        try:
            # –û—á–∏—Å—Ç–∫–∞ –∫–µ—à–µ–π –∏ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è —Å–±–æ—Ä–∫–∞ –º—É—Å–æ—Ä–∞
            import gc

            # –û—á–∏—â–∞–µ–º –º–µ—Ç—Ä–∏–∫–∏ (–æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 100)
            if len(self.system_metrics) > 100:
                while len(self.system_metrics) > 100:
                    self.system_metrics.popleft()

            # –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –∞–ª–µ—Ä—Ç—ã
            cutoff = datetime.now() - timedelta(hours=1)
            self.active_alerts = {
                k: v for k, v in self.active_alerts.items()
                if v.timestamp > cutoff or not v.resolved
            }

            collected = gc.collect()
            logger.info(f"üîß Memory –∏—Å—Ü–µ–ª–µ–Ω–∏–µ: –æ—á–∏—â–µ–Ω–æ –∫–µ—à–µ–π, —Å–æ–±—Ä–∞–Ω–æ {collected} –æ–±—ä–µ–∫—Ç–æ–≤")

            return True

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∏—Å—Ü–µ–ª–µ–Ω–∏—è –ø–∞–º—è—Ç–∏: {e}")
            return False

    async def _heal_scheduler(self) -> bool:
        """–ò—Å—Ü–µ–ª–µ–Ω–∏–µ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞"""
        try:
            if self.scheduler and not self.scheduler.running:
                self.scheduler.start()
                logger.info("üîß –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω")
                return True
            return False

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∏—Å—Ü–µ–ª–µ–Ω–∏—è –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞: {e}")
            return False

    async def _heal_database(self) -> bool:
        """–ò—Å—Ü–µ–ª–µ–Ω–∏–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
        try:
            if self.db:
                # –ü–µ—Ä–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ë–î
                await self.db.init_database()
                logger.info("üîß –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –ø–µ—Ä–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
                return True
            return False

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∏—Å—Ü–µ–ª–µ–Ω–∏—è –ë–î: {e}")
            return False

    def get_system_status(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ —Å–∏—Å—Ç–µ–º—ã"""
        if not self.system_metrics:
            return {
                'status': 'no_data',
                'message': '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞'
            }

        latest = self.system_metrics[-1]
        active_alerts = [a for a in self.active_alerts.values() if not a.resolved]

        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–±—â–∏–π —Å—Ç–∞—Ç—É—Å
        critical_alerts = [a for a in active_alerts if a.level == 'critical']
        error_alerts = [a for a in active_alerts if a.level == 'error']

        if critical_alerts:
            status = 'critical'
            emoji = 'üî¥'
        elif error_alerts:
            status = 'error'
            emoji = 'üü†'
        elif active_alerts:
            status = 'warning'
            emoji = 'üü°'
        else:
            status = 'healthy'
            emoji = 'üü¢'

        return {
            'status': status,
            'emoji': emoji,
            'cpu_percent': latest.cpu_percent,
            'memory_percent': latest.memory_percent,
            'disk_percent': latest.disk_percent,
            'active_alerts_count': len(active_alerts),
            'critical_alerts': len(critical_alerts),
            'healing_actions': dict(self.healing_actions),
            'monitoring_active': self.running,
            'last_check': latest.timestamp.isoformat()
        }

    def get_metrics_summary(self, hours: int = 1) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–æ–¥–∫–∏ –º–µ—Ç—Ä–∏–∫"""
        if not self.system_metrics:
            return {}

        # –§–∏–ª—å—Ç—Ä—É–µ–º –º–µ—Ç—Ä–∏–∫–∏ –∑–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥
        since = datetime.now() - timedelta(hours=hours)
        recent_metrics = [m for m in self.system_metrics if m.timestamp > since]

        if not recent_metrics:
            return {}

        cpu_values = [m.cpu_percent for m in recent_metrics]
        memory_values = [m.memory_percent for m in recent_metrics]
        disk_values = [m.disk_percent for m in recent_metrics]

        return {
            'period_hours': hours,
            'data_points': len(recent_metrics),
            'cpu': {
                'avg': sum(cpu_values) / len(cpu_values),
                'max': max(cpu_values),
                'min': min(cpu_values)
            },
            'memory': {
                'avg': sum(memory_values) / len(memory_values),
                'max': max(memory_values),
                'min': min(memory_values)
            },
            'disk': {
                'avg': sum(disk_values) / len(disk_values),
                'max': max(disk_values),
                'min': min(disk_values)
            }
        }